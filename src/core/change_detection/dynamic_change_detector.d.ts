import { AbstractChangeDetector } from './abstract_change_detector';
import { EventBinding } from './event_binding';
import { BindingRecord, BindingTarget } from './binding_record';
import { DirectiveRecord, DirectiveIndex } from './directive_record';
import { Locals } from './parser/locals';
import { ChangeDetectorGenConfig } from './interfaces';
import { SimpleChange } from './change_detection_util';
import { ChangeDetectionStrategy } from './constants';
import { ProtoRecord } from './proto_record';
export declare class DynamicChangeDetector extends AbstractChangeDetector<any> {
    private _records;
    private _eventBindings;
    private _directiveRecords;
    private _genConfig;
    values: any[];
    changes: any[];
    localPipes: any[];
    prevContexts: any[];
    directives: any;
    constructor(id: string, dispatcher: any, numberOfPropertyProtoRecords: number, propertyBindingTargets: BindingTarget[], directiveIndices: DirectiveIndex[], strategy: ChangeDetectionStrategy, _records: ProtoRecord[], _eventBindings: EventBinding[], _directiveRecords: DirectiveRecord[], _genConfig: ChangeDetectorGenConfig);
    handleEventInternal(eventName: string, elIndex: number, locals: Locals): boolean;
    _processEventBinding(eb: EventBinding, locals: Locals): any;
    _markPathAsCheckOnce(proto: ProtoRecord): void;
    _matchingEventBindings(eventName: string, elIndex: number): EventBinding[];
    hydrateDirectives(directives: any): void;
    dehydrateDirectives(destroyPipes: boolean): void;
    _destroyPipes(): void;
    checkNoChanges(): void;
    detectChangesInRecordsInternal(throwOnChange: boolean): void;
    _firstInBinding(r: ProtoRecord): boolean;
    afterContentLifecycleCallbacksInternal(): void;
    afterViewLifecycleCallbacksInternal(): void;
    _updateDirectiveOrElement(change: any, bindingRecord: any): void;
    _addChange(bindingRecord: BindingRecord, change: any, changes: any): any;
    _getDirectiveFor(directiveIndex: any): any;
    _getDetectorFor(directiveIndex: any): any;
    _check(proto: ProtoRecord, throwOnChange: boolean, values: any[], locals: Locals): SimpleChange;
    _referenceCheck(proto: ProtoRecord, throwOnChange: boolean, values: any[], locals: Locals): SimpleChange;
    _calculateCurrValue(proto: ProtoRecord, values: any[], locals: Locals): any;
    _pipeCheck(proto: ProtoRecord, throwOnChange: boolean, values: any[]): SimpleChange;
    _pipeFor(proto: ProtoRecord, context: any): any;
    _readContext(proto: ProtoRecord, values: any[]): any;
    _readSelf(proto: ProtoRecord, values: any[]): any;
    _writeSelf(proto: ProtoRecord, value: any, values: any[]): void;
    _readPipe(proto: ProtoRecord): any;
    _writePipe(proto: ProtoRecord, value: any): void;
    _setChanged(proto: ProtoRecord, value: boolean): void;
    _pureFuncAndArgsDidNotChange(proto: ProtoRecord): boolean;
    _argsChanged(proto: ProtoRecord): boolean;
    _argsOrContextChanged(proto: ProtoRecord): boolean;
    _readArgs(proto: ProtoRecord, values: any[]): any[];
}
